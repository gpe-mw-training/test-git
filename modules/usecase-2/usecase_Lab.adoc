== Use Case 2 - Camel Route aggregating messages enriched and transformed from REST & WebServices endpoints

Process the JSON files generated by the use case 1, send each JSON Object to a REST endpoint responsible to enrich the message and a Web Service responsible to transform the result returned in XML format.
Aggregate the responses received and take care about the transformation XML/JSon. Publish the result into a H2 DB using the SQL/JDBC component. The definition of the WSDL, JSON files, WebService, REST Service & DB will be provided.

.Goals
* Design the Apache Camel routes consuming the json files and exposing the REST and WebService endpoint
* Use the multicast EIP pattern to distribute the messages to the services (REST/WebService)
* Design the CXF Web Service using jax-ws annotations
* Use Camel CXFRS component to setup the Client & REST Server
* Aggregate the messages received using the aggregation EIP pattern
* Save the message aggregated into a SQL database using the Spring SQL component

:numbered:

== Import the Project (TODO - Discuss how we will setup the project)

. In JBoss Developer Studio, switch to the *Git* perspective. 
. Click the icon at the top to clone a Git repository and add the clone to this view.
. In the *URI* text box, copy and paste the following: 
+
------
https://github.com/gpe-mw-training/fuse-for-practitioners-labs.git
------
+
. Switch to *Project Explorer* for the *JBoss* perspective.
. Import a new Maven project by selecting *File -> Import -> Maven -> Existing Maven Projects -> Next*. Import the `core` and it's parent project
. Navigate to the location of the Git projects for the Data Transformation tool and click *Finish*.
. Click the *Project Explorer* tab and expand the `Inbound` project node. 
+  
.Application structure
image::images/application_structure.png[width="40%"]

. Examine the following files and folders that appear in the expanded view:

* `routing`: module in which you will develop the `route`, `unit test` of the use-case.
** `src/main/resources/schema` : JSON and csv schemas files you will need to create the Data Transformation
* `parent` : Contain JBoss Fuse 6.2.1 dependencies, properties definition and maven plugins used by the modules
* `features` : Apache Karaf XML features file to be used to deploy the `usecase` project on JBoss Fuse without Fabric technology

=== Setup the database

To use the Camel SQL component it is required that first you setup a database. Follow these instructions

- [Download](http://www.h2database.com/html/main.html) the H2 database
- Unzip the content and open a terminal
- Launch it `./h2-1.4.190/bin/h2.sh`
- Within your browser `http://localhost:8082/login.jsp`, setup the connection

```
Driver class : org.h2.Driver
JDBC Url : jdbc:h2:tcp://localhost/~/usecaseDB
User : sa
Password :
```

- Create the DB using the `routing/src/main/resources/schema/db/usecaseDB.sql` script and run these commands within the browser

```
DROP SCHEMA USECASE;
CREATE SCHEMA USECASE;
CREATE TABLE USECASE.T_ACCOUNT (
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY(START WITH 1) NOT NULL PRIMARY KEY,
    CLIENT_ID BIGINT,
    SALES_CONTACT VARCHAR(30),
    COMPANY_NAME VARCHAR(50),
    COMPANY_GEO CHAR(20) ,
    COMPANY_ACTIVE BOOLEAN,
    CONTACT_FIRST_NAME VARCHAR(35),
    CONTACT_LAST_NAME VARCHAR(35),
    CONTACT_ADDRESS VARCHAR(255),
    CONTACT_CITY VARCHAR(40),
    CONTACT_STATE VARCHAR(40),
    CONTACT_ZIP VARCHAR(10),
    CONTACT_EMAIL VARCHAR(60),
    CONTACT_PHONE VARCHAR(35),
    CREATION_DATE TIMESTAMP,
    CREATION_USER VARCHAR(255)
);
```

- Include a bean defintion with the Apache Route to declare the Datasource that the SQL component will use to accesss
  the database

```
<!-- H2 DB -->
<bean id="usecaseDB" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
    <property name="driverClassName" value="org.h2.Driver"/>
    <property name="url" value="jdbc:h2:tcp://localhost/~/usecaseDB"/>
    <property name="username" value="sa"/>
    <property name="password" value=""/>
</bean>
``

=== Design the REST Service

In order to update the `Account` POJO that you will consume from the JSon files (created during the realisation of the previous use case), then you will expose a REST service
where you will send using a POST method the JSon body content of the Account POJO. The REST `CustomerRest` service must be created as such

```
@Path("/customerservice/")
public interface CustomerRest {

    @POST @Path("/enrich") @Consumes("application/json")
    Account enrich(Account customer);
```

The class implementing it will contain the following logic to enrich the Account POJO. Base on the geo field of the Company object, you will select from a java enum class the region which is associated to the code "na,sa,wa,ea"
with respectively one of these values "NORTH_AMERICA,SOUTH_AMERICA,WEST_AMERICA,EAST_AMERICA". The enum selected will replace the 2 letters region code. The Account object enriched will be returned by the method enrich().

NOTE: To expose the REST service within the Apache Camel route, you will use the `rsServer` server of the CXF component and define the different parameters as such: id = customerRestService, address = http://localhost:9191/rest, serviceClass = org.fuse.usecase.service.CustomerRest
and enable the logging with the parameter loggingFeatureEnabled = true. To parse the JSon string to a POJO or the opposite, you will use this Json parser `com.fasterxml.jackson.jaxrs.json.JacksonJaxbJsonProvider` which is defined by the maven artifact `jackson-jaxrs-json-provider`

=== Design the Web Service Service

The other service to be developed is a Web Service that you will define within the interface `CustomerWS` using the @Webservice annotation. The service will expose
an operation to update the account object received

```
@WebService
public interface CustomerWS {

    CorporateAccount updateAccount(Account account);
```

Base on the Account POJO received, you will create a CorporateAccount POJO containing the same fields as the Account plus 2 additional fields; id (int) and salesContact (String) that you will use
to set a random value created with the range values (1 to 100) and where the salesContact field will be populated randomly too using a List of Contacts. The CorporateAccount is returned by the
`updateAccount` method implemented within the class `CustomerWSImpl`

NOTE : An Apache Camel CXF endpoint bean will be used to configure the Web Service and will created using these parameters; id = customerWebService, address = http://localhost:9090/ws/customerService,
serviceClass = org.fuse.usecase.service.CustomerWS and loggingFeatureEnabled = true

=== Develop the Routing module

Based on the skeleton code provided, create a new route where you will consume the json files using this uri endpoint

File uri outbox endpoint : src/data/inbox?fileName=customers.csv&amp;noop=true

Convert the content to a String and next unmarshall the String JSon content to a POJO using the processor <unmarshal>.
The json library to be used is `jackson` and the unmarshalTypeName is `nmarshalTypeName`

The result unmarshalled will be used to multicast the exchange to the REST and Web Service endpoints

NOTE: Don't multicast the exchange in parallel
IMPORTANT: To simplify the readability of the code, use a direct endpoint `callRestEndpoint` to call the REST service
and another to call the WebService `callWSEndpoint

=== Define the Rest Direct Route

In order to call the services, you will create 2 routes; one starting with the `direct:callRestEndpoint` and the other with `direct:callWSEndpoint`.
The first camel route will call the REST endpoint using the `cxfrs:bean` client. So, like the `rsServer` bean, you will creat a `rsClient` bean to access
the REST endpoint.

NOTE: The parameters to be used for the `rsClient` are similar to the ones used for the `rsServer`
WARNING: Don't forget to setup the HTTP Parameters required to specify the `Content-Type` and `Accept` properties for `application/json`
like also the method to be used to POST the HTTP request. The HTTP Path must be defined too to access the operation method of the service like also the
Cxf HEADER CamelCxfRsUsingHttpAPI (= True)
WARNING: Depending on the object returned by the `<cxfrs:bean:customerRestServiceClient>` a data transformation will be required to process
the response that you will receive in order to generate an `Account` object. So, it will be perhaps required to create a method converting the object type received
to a String type that next Jackson marshaller can handle.

=== Define the WebService Direct Route

Developp also a Direct Web Service route which start with the direct endpoint `direct://callWSEndpoint` and call the WebService
using the Camel CXF Producer.

=== Expose the REST and Web Services

Create 2 Apache Camel routes to expose the CXF Web Service and REST endpoint using respectively the `cxf:bean` and `cxfrs:bean` endpoint. The bean to be used should
correspond to the `rsServer` and `cxfEndpoint` beans created previously.

The route exposing the Web Service will next call the method `updateAccount` of the Apache Camel bean `CustomerWSImplBean` while the other route will call
the method `enrich` of the Apache Camel Bean `CustomerRestImplBean`.

=== Design the aggregation strategy

From the result collected by the 2 services called, you will aggregate the content within the `multicast` processor in order
to reconcile the information received from the `CorporateAccount` POJO with the `Account` POJO. This new `Account` POJO will correspond to the aggregated
result that you will next send to another Apache Camel route exposed by the `direct:insertDB` endpoint.

NOTE: The Aggregation strategy must be developed within the `AccountAggregator` class.

=== Insert the Account aggregated into the H2 Database

Create a new Apache Camel route to insert into the table T_ACCOUNT of the database ACCOUNT, the Account information.
For that purpose, you will use the Spring SQL component and specify within the option parameter of the SQL endpoint the SQL query
to be used to insert the Account record. The named parameters will be defined using a Map<String, Object> that you will create
within a Bean called by the route to set the Body before to call the SQL endpoint. After calling the SQL endpoint, add a log message processor to display the
content of the body received.

Bean to be created : ProcessorBean.class
Method creating the named parameters : defineNamedParameters(Account account)

=== Develop a JUnit Test

Develop a Junit Test case to validate that the Jackson ObjectMapper can read the string content of a Json Account message
and generate an Account object. Define two assert conditions; one to check that the object is not null and the other
to verify that the name of the company is equal to "Robocops".

Name of the Junit Test class : JacksonCompanyTest

=== Build the `routing` Project & test it locally

. On the command line, run the following commands in a terminal

[source]
----
./h2-1.4.190/bin/h2.sh
----

. and these in another terminal :

[source]
----
mvn clean install
mvn camel:run
----

You should get this message if your code is correct

```
{CONTACT_STATE=NC, SALES_CONTACT=Guillaume Nodet, CREATION_USER=fuse_usecase, CREATION_DATE=2015-12-11 18:18:01.55, CONTACT_PHONE=600-555-7000, CONTACT_CITY=Raleigh, CONTACT_ADDRESS=1101 Smith St., COMPANY_NAME=MountainBikers, COMPANY_ACTIVE=true, CLIENT_ID=46, CONTACT_LAST_NAME=Jungle, CONTACT_ZIP=27519, COMPANY_GEO=SOUTH_AMERICA, CONTACT_FIRST_NAME=George}
```

IMPORTANT: CREATION_DATE, SALES_CONTACT and CLIENT_ID will vary for you as they are generated

=== Bonus

Define the features XML file to deploy the project on JBoss Fuse 6.2.1 and test it using these commands to be executed within the Fuse console.

[source]
----
addurl mvn:org.fuse.usecase2/features/1.0/xml/features
features:install usecase-camel-aggregation-db
----

Instead of using the features XML file, you can also create a Fabric8 profile by editing the <fabric8.xxxx> xml tags that you have within the pom.xml routing file
and next execute this command to create the profile into JBoss Fuse Fabric

[source]
----
mvn fabric8:deploy
----



